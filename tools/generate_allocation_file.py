import os
import platform
import sys
import csv
import yaml
from pathlib import Path


class Allocation:
    def __init__(self):
        self.engine_name = []
        self.device_name = []
        self.network_name = []
        self.total_networks = 0
        self.layer_param_data = []
        self.mem_size = 0.0
        self.layer_names = []
        self.layer_sizes = []
        self.layer_comp_cycles = []
        self.layer_data_cycles = []
        self.layer_network = []
        self.network_paths = []
        self.layer_delta_cycles = []
        self.layer_list = []

    def validate_input(self, layer_param_data, mem_sizes):
        if not os.path.exists(layer_param_data):
            print("Please enter a valid path to the CSV file")
            sys.exit(1)

        for size in mem_sizes:
            if size.isdigit():
                pass
            else:
                print("Please enter valid numerical sizes in the format: \"8, 24, 30\"")
                sys.exit(1)

    def load_csv(self, layer_param_data):
        """
        Loads CSV file argument and stores it as a list in class

        :layer_param_data: path to stat CSV file generated by ArchBench
        """
        for idx, network_path in enumerate(layer_param_data):
            with open(network_path) as csvfile:
                layer_data_csv = csv.reader(csvfile, delimiter=',')
                self.layer_param_data.append(list(layer_data_csv))
                self.network_paths.append(network_path)
                for weight in self.layer_param_data[idx][1:]:
                    weight.append(network_path)

                network_name = ""
                device_name = ""
                engine_name = ""

                try:
                    network_name = os.path.basename(network_path).split('.', 1)[0]
                    config_path = Path(network_path).parent.parent.joinpath("0_config_files")
                    for file in os.listdir(config_path):
                        if file.endswith(".yaml"):
                            device_name = file.split('-')[0]
                            engine_name = file.split('.')[0].split('-')[1]

                except FileNotFoundError:
                    network_name = Path(network_path).stem.split('.')[0] if network_name == "" else network_name
                    device_name = "Device" + str(idx) if device_name == "" else device_name
                    engine_name = "VPU" if engine_name == "" else engine_name

                self.network_name.append(network_name)
                self.device_name.append(device_name)
                self.engine_name.append(engine_name)

    def set_mem_size(self, mem_size):
        self.mem_size = float(mem_size)

    def set_total_networks(self, network_amount):
        self.total_networks = network_amount

    def parse_csv(self):
        """
        Parses list generated from CSV and stores names, sizes, and cycles in class

        """
        header = self.layer_param_data[0][0]

        layer_names = []
        layer_sizes = []
        layer_comp_cycles = []
        layer_data_cycles = []
        layer_network = []

        for network in range(self.total_networks):
            for layer in self.layer_param_data[network][1:]:
                layer_names.append(layer[header.index("Layer Name")])
                layer_sizes.append(float(layer[header.index("Read Param Transfer (Ki)")]))
                layer_comp_cycles.append(layer[header.index("Comp Cycles")])
                layer_data_cycles.append(layer[header.index("Data Cycles")])
                layer_network.append(layer[-1])

        self.layer_names = layer_names
        self.layer_sizes = layer_sizes
        self.layer_comp_cycles = layer_comp_cycles
        self.layer_data_cycles = layer_data_cycles
        self.layer_network = layer_network

    def convert_layer_size(self):
        """
        Converts layer sizes from Ki to MB

        """
        layer_sizes = []
        for ki_size in self.layer_sizes:
            byte_size = ki_size * (2**10)
            megabyte_size = byte_size / (10**6)
            layer_sizes.append(megabyte_size)
        self.layer_sizes = layer_sizes

    def calculate_layer_deltas(self):
        """
        Calculates delta between data and comp cycles. Positive indicates memory bound layers

        """
        for idx, comp_cycles in enumerate(self.layer_comp_cycles):
            data_cycles = self.layer_data_cycles[idx]
            delta = float(data_cycles) - float(comp_cycles)
            self.layer_delta_cycles.append(round(delta, 2))

    def generate_dict(self):
        """
        Creates a dictionary-style list with layer names corresponding to cycle delta and size

        """
        layer_dict = dict()
        for idx, name in enumerate(self.layer_names):
            layer_dict[name] = (self.layer_delta_cycles[idx], self.layer_sizes[idx], self.layer_network[idx])

        self.layer_list = sorted(layer_dict.items(), key=lambda x: x[1], reverse=True)

    def generate_allocation(self):
        """
        Allocating highest memory bound layers to CSRAM until full. Generating YAML allocation file

        """
        mem_size_mebibyte = self.mem_size
        mem_size_megabyte = mem_size_mebibyte * ((2**20) / (10**6))
        CSRAM_size_available = mem_size_megabyte

        network_paths = self.network_paths
        for network_idx, network in enumerate(
                network_paths):  #Inefficient nested loop approach, change to single for loop approach
            CSRAM_layers = {}
            DDR_layers = {}

            for idx, (name, key) in enumerate(self.layer_list):
                layer_size = key[1]
                layer_network = key[2]
                if network == layer_network:
                    if layer_size == 0.0:
                        continue
                    elif layer_size <= CSRAM_size_available:
                        CSRAM_size_available = CSRAM_size_available - layer_size
                        CSRAM_layers[name] = 1.0
                        DDR_layers[name] = 0.0
                    else:
                        CSRAM_layers[name] = 0.0
                        DDR_layers[name] = 1.0
                else:
                    pass

            yaml_data = dict()
            yaml_data.update({"CSRAM": CSRAM_layers})
            yaml_data.update({"DDR": DDR_layers})

            allocation_fname = self.network_name[network_idx] + "-" + self.device_name[
                network_idx] + "-" + self.engine_name[network_idx] + "-" + str(self.mem_size) + "MB" + "-alloc.yaml"

            allocation_write_fname = os.path.join(os.path.dirname(sys.path[0]), 'Allocation_Data', allocation_fname)
            with open(allocation_write_fname, 'w') as file:
                yaml.dump(yaml_data, file)


layer_param_data = []
layer_param_data = sys.argv[1:-1]
mem_sizes = [size.strip() for size in sys.argv[-1].split(',')]

run = Allocation()
run.set_total_networks(len(layer_param_data))
#run.validate_input(layer_param_data, mem_sizes)
run.load_csv(layer_param_data)
run.parse_csv()
run.convert_layer_size()
run.calculate_layer_deltas()
run.generate_dict()
for size in mem_sizes:
    run.set_mem_size(size)
    run.generate_allocation()
print("Generated")
